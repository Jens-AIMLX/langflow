{
  "access_type": "PRIVATE",
  "action_description": null,
  "action_name": null,
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "File",
            "id": "File-sQtW8",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data",
            "id": "PdfToImagesComponent-jqRP1",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-File-sQtW8{œdataTypeœ:œFileœ,œidœ:œFile-sQtW8œ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-PdfToImagesComponent-jqRP1{œfieldNameœ:œdataœ,œidœ:œPdfToImagesComponent-jqRP1œ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "File-sQtW8",
        "sourceHandle": "{œdataTypeœ:œFileœ,œidœ:œFile-sQtW8œ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}",
        "target": "PdfToImagesComponent-jqRP1",
        "targetHandle": "{œfieldNameœ:œdataœ,œidœ:œPdfToImagesComponent-jqRP1œ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TesseractLocalOCR",
            "id": "TesseractLocalOCR-pS1zU",
            "name": "ocr_text",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data",
            "id": "ParseData-ubkRq",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-TesseractLocalOCR-pS1zU{œdataTypeœ:œTesseractLocalOCRœ,œidœ:œTesseractLocalOCR-pS1zUœ,œnameœ:œocr_textœ,œoutput_typesœ:[œDataœ]}-ParseData-ubkRq{œfieldNameœ:œdataœ,œidœ:œParseData-ubkRqœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "TesseractLocalOCR-pS1zU",
        "sourceHandle": "{œdataTypeœ:œTesseractLocalOCRœ,œidœ:œTesseractLocalOCR-pS1zUœ,œnameœ:œocr_textœ,œoutput_typesœ:[œDataœ]}",
        "target": "ParseData-ubkRq",
        "targetHandle": "{œfieldNameœ:œdataœ,œidœ:œParseData-ubkRqœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "PdfToImagesComponent",
            "id": "PdfToImagesComponent-jqRP1",
            "name": "image_paths",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "file_data",
            "id": "TesseractLocalOCR-pS1zU",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-PdfToImagesComponent-jqRP1{œdataTypeœ:œPdfToImagesComponentœ,œidœ:œPdfToImagesComponent-jqRP1œ,œnameœ:œimage_pathsœ,œoutput_typesœ:[œDataœ]}-TesseractLocalOCR-pS1zU{œfieldNameœ:œfile_dataœ,œidœ:œTesseractLocalOCR-pS1zUœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "PdfToImagesComponent-jqRP1",
        "sourceHandle": "{œdataTypeœ:œPdfToImagesComponentœ,œidœ:œPdfToImagesComponent-jqRP1œ,œnameœ:œimage_pathsœ,œoutput_typesœ:[œDataœ]}",
        "target": "TesseractLocalOCR-pS1zU",
        "targetHandle": "{œfieldNameœ:œfile_dataœ,œidœ:œTesseractLocalOCR-pS1zUœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "RTFParser",
            "id": "File-si0o5",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "rtf_text",
            "id": "CustomComponent-wJ5Yy",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__File-si0o5{œdataTypeœ:œRTFParserœ,œidœ:œFile-si0o5œ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-wJ5Yy{œfieldNameœ:œrtf_textœ,œidœ:œCustomComponent-wJ5Yyœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "File-si0o5",
        "sourceHandle": "{œdataTypeœ:œRTFParserœ,œidœ:œFile-si0o5œ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "CustomComponent-wJ5Yy",
        "targetHandle": "{œfieldNameœ:œrtf_textœ,œidœ:œCustomComponent-wJ5Yyœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParseData",
            "id": "ParseData-ubkRq",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "pdf_text",
            "id": "CustomComponent-wJ5Yy",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParseData-ubkRq{œdataTypeœ:œParseDataœ,œidœ:œParseData-ubkRqœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-wJ5Yy{œfieldNameœ:œpdf_textœ,œidœ:œCustomComponent-wJ5Yyœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParseData-ubkRq",
        "sourceHandle": "{œdataTypeœ:œParseDataœ,œidœ:œParseData-ubkRqœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "CustomComponent-wJ5Yy",
        "targetHandle": "{œfieldNameœ:œpdf_textœ,œidœ:œCustomComponent-wJ5Yyœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "OllamaTwoPhase",
            "id": "CustomComponent-wJ5Yy",
            "name": "response",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data",
            "id": "ParseData-WoS96",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CustomComponent-wJ5Yy{œdataTypeœ:œOllamaTwoPhaseœ,œidœ:œCustomComponent-wJ5Yyœ,œnameœ:œresponseœ,œoutput_typesœ:[œDataœ]}-ParseData-WoS96{œfieldNameœ:œdataœ,œidœ:œParseData-WoS96œ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "CustomComponent-wJ5Yy",
        "sourceHandle": "{œdataTypeœ:œOllamaTwoPhaseœ,œidœ:œCustomComponent-wJ5Yyœ,œnameœ:œresponseœ,œoutput_typesœ:[œDataœ]}",
        "target": "ParseData-WoS96",
        "targetHandle": "{œfieldNameœ:œdataœ,œidœ:œParseData-WoS96œ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParseData",
            "id": "ParseData-WoS96",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-1EnB8",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ParseData-WoS96{œdataTypeœ:œParseDataœ,œidœ:œParseData-WoS96œ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-1EnB8{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-1EnB8œ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ParseData-WoS96",
        "sourceHandle": "{œdataTypeœ:œParseDataœ,œidœ:œParseData-WoS96œ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-1EnB8",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-1EnB8œ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt",
            "id": "Prompt-gdYgY",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "compose_prompt",
            "id": "CustomComponent-wJ5Yy",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt-gdYgY{œdataTypeœ:œPromptœ,œidœ:œPrompt-gdYgYœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-wJ5Yy{œfieldNameœ:œcompose_promptœ,œidœ:œCustomComponent-wJ5Yyœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt-gdYgY",
        "sourceHandle": "{œdataTypeœ:œPromptœ,œidœ:œPrompt-gdYgYœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "CustomComponent-wJ5Yy",
        "targetHandle": "{œfieldNameœ:œcompose_promptœ,œidœ:œCustomComponent-wJ5Yyœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-KwmJ2",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "chat_input",
            "id": "CustomComponent-wJ5Yy",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ChatInput-KwmJ2{œdataTypeœ:œChatInputœ,œidœ:œChatInput-KwmJ2œ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-wJ5Yy{œfieldNameœ:œchat_inputœ,œidœ:œCustomComponent-wJ5Yyœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ChatInput-KwmJ2",
        "sourceHandle": "{œdataTypeœ:œChatInputœ,œidœ:œChatInput-KwmJ2œ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}",
        "target": "CustomComponent-wJ5Yy",
        "targetHandle": "{œfieldNameœ:œchat_inputœ,œidœ:œCustomComponent-wJ5Yyœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt",
            "id": "Prompt-Jx0tt",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "extract_prompt",
            "id": "CustomComponent-wJ5Yy",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt-Jx0tt{œdataTypeœ:œPromptœ,œidœ:œPrompt-Jx0ttœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-wJ5Yy{œfieldNameœ:œextract_promptœ,œidœ:œCustomComponent-wJ5Yyœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt-Jx0tt",
        "sourceHandle": "{œdataTypeœ:œPromptœ,œidœ:œPrompt-Jx0ttœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "CustomComponent-wJ5Yy",
        "targetHandle": "{œfieldNameœ:œextract_promptœ,œidœ:œCustomComponent-wJ5Yyœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "description": "Display a chat message in the Playground.",
          "display_name": "Chat Output",
          "id": "ChatOutput-1EnB8",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.4.0",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": true,
                "method": "message_response",
                "name": "message",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean the data",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            info=\"Whether to clean the data\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                if data.get_text() is None:\n                    msg = \"Empty Data object\"\n                    raise ValueError(msg)\n                return data.get_text()\n            if isinstance(data, DataFrame):\n                if self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n\n                # Replace pipe characters to avoid markdown table issues\n                processed_data = data.replace(r\"\\|\", r\"\\\\|\", regex=True)\n\n                processed_data = processed_data.map(\n                    lambda x: str(x).replace(\"\\n\", \"<br/>\") if isinstance(x, str) else x\n                )\n\n                return processed_data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            return \"\\n\".join([self._safe_convert(item) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return self._safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "type": "ChatOutput"
        },
        "dragging": false,
        "height": 234,
        "id": "ChatOutput-1EnB8",
        "measured": {
          "height": 234,
          "width": 320
        },
        "position": {
          "x": 2197.982590069088,
          "y": 375.1619533025102
        },
        "positionAbsolute": {
          "x": 1631.3766926569258,
          "y": 136.66509468115308
        },
        "selected": false,
        "type": "genericNode",
        "width": 320
      },
      {
        "data": {
          "description": "Convert Data objects into Messages using any {field_name} from input data.",
          "display_name": "Data to Message",
          "id": "ParseData-ubkRq",
          "node": {
            "base_classes": [
              "Data",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Convert Data objects into Messages using any {field_name} from input data.",
            "display_name": "Data to Message",
            "documentation": "",
            "edited": false,
            "field_order": [
              "data",
              "template",
              "sep"
            ],
            "frozen": false,
            "icon": "message-square",
            "legacy": true,
            "lf_version": "1.4.0",
            "metadata": {
              "legacy_name": "Parse Data"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": false,
                "method": "parse_data",
                "name": "text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data List",
                "hidden": true,
                "method": "parse_data_as_list",
                "name": "data_list",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.helpers.data import data_to_text, data_to_text_list\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass ParseDataComponent(Component):\n    display_name = \"Data to Message\"\n    description = \"Convert Data objects into Messages using any {field_name} from input data.\"\n    icon = \"message-square\"\n    name = \"ParseData\"\n    legacy = True\n    metadata = {\n        \"legacy_name\": \"Parse Data\",\n    }\n\n    inputs = [\n        DataInput(\n            name=\"data\",\n            display_name=\"Data\",\n            info=\"The data to convert to text.\",\n            is_list=True,\n            required=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {data} or any other key in the Data.\",\n            value=\"{text}\",\n            required=True,\n        ),\n        StrInput(name=\"sep\", display_name=\"Separator\", advanced=True, value=\"\\n\"),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"text\",\n            info=\"Data as a single Message, with each input Data separated by Separator\",\n            method=\"parse_data\",\n        ),\n        Output(\n            display_name=\"Data List\",\n            name=\"data_list\",\n            info=\"Data as a list of new Data, each having `text` formatted by Template\",\n            method=\"parse_data_as_list\",\n        ),\n    ]\n\n    def _clean_args(self) -> tuple[list[Data], str, str]:\n        data = self.data if isinstance(self.data, list) else [self.data]\n        template = self.template\n        sep = self.sep\n        return data, template, sep\n\n    def parse_data(self) -> Message:\n        data, template, sep = self._clean_args()\n        result_string = data_to_text(template, data, sep)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def parse_data_as_list(self) -> list[Data]:\n        data, template, _ = self._clean_args()\n        text_list, data_list = data_to_text_list(template, data)\n        for item, text in zip(data_list, text_list, strict=True):\n            item.set_text(text)\n        self.status = data_list\n        return data_list\n"
              },
              "data": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Data",
                "dynamic": false,
                "info": "The data to convert to text.",
                "input_types": [
                  "Data"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sep": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              },
              "template": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{ocr_text}  "
              }
            },
            "tool_mode": false
          },
          "type": "ParseData"
        },
        "dragging": false,
        "height": 302,
        "id": "ParseData-ubkRq",
        "measured": {
          "height": 302,
          "width": 320
        },
        "position": {
          "x": 952.3193873246481,
          "y": 859.3459519731535
        },
        "positionAbsolute": {
          "x": 514.8054600415829,
          "y": -117.1921617826383
        },
        "selected": false,
        "type": "genericNode",
        "width": 320
      },
      {
        "data": {
          "id": "File-sQtW8",
          "node": {
            "base_classes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Load a file to be used in your project.",
            "display_name": "Source File",
            "documentation": "",
            "edited": true,
            "field_order": [
              "path",
              "file_path",
              "separator",
              "silent_errors",
              "delete_server_file_after_processing",
              "ignore_unsupported_extensions",
              "ignore_unspecified_files",
              "use_multithreading",
              "concurrency_multithreading"
            ],
            "frozen": false,
            "icon": "file-text",
            "legacy": false,
            "lf_version": "1.4.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "hidden": false,
                "method": "load_files",
                "name": "data",
                "options": null,
                "required_inputs": [],
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "DataFrame",
                "hidden": true,
                "method": "load_dataframe",
                "name": "dataframe",
                "options": null,
                "required_inputs": [],
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": true,
                "method": "load_message",
                "name": "message",
                "options": null,
                "required_inputs": [],
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.data import BaseFileComponent\nfrom langflow.base.data.utils import TEXT_FILE_TYPES, parallel_load_data, parse_text_file_to_data\nfrom langflow.io import BoolInput, IntInput\nfrom langflow.schema import Data\n\n\nclass FileComponent(BaseFileComponent):\n    \"\"\"Handles loading and processing of individual or zipped text files.\n\n    This component supports processing multiple valid files within a zip archive,\n    resolving paths, validating file types, and optionally using multithreading for processing.\n    \"\"\"\n\n    display_name = \"Source File\"\n    description = \"Load a file to be used in your project.\"\n    icon = \"file-text\"\n    name = \"File\"\n\n    VALID_EXTENSIONS = TEXT_FILE_TYPES\n\n    inputs = [\n        *BaseFileComponent._base_inputs,\n        BoolInput(\n            name=\"use_multithreading\",\n            display_name=\"[Deprecated] Use Multithreading\",\n            advanced=True,\n            value=True,\n            info=\"Set 'Processing Concurrency' greater than 1 to enable multithreading.\",\n        ),\n        IntInput(\n            name=\"concurrency_multithreading\",\n            display_name=\"Processing Concurrency\",\n            advanced=True,\n            info=\"When multiple files are being processed, the number of files to process concurrently.\",\n            value=1,\n        ),\n    ]\n\n    outputs = [\n        *BaseFileComponent._base_outputs,\n    ]\n\n    def process_files(self, file_list: list[BaseFileComponent.BaseFile]) -> list[BaseFileComponent.BaseFile]:\n        \"\"\"Processes files either sequentially or in parallel, depending on concurrency settings.\n\n        Args:\n            file_list (list[BaseFileComponent.BaseFile]): List of files to process.\n\n        Returns:\n            list[BaseFileComponent.BaseFile]: Updated list of files with merged data.\n        \"\"\"\n\n        def process_file(file_path: str, *, silent_errors: bool = False) -> Data | None:\n            \"\"\"Processes a single file and returns its Data object.\"\"\"\n            try:\n                return parse_text_file_to_data(file_path, silent_errors=silent_errors)\n            except FileNotFoundError as e:\n                msg = f\"File not found: {file_path}. Error: {e}\"\n                self.log(msg)\n                if not silent_errors:\n                    raise\n                return None\n            except Exception as e:\n                msg = f\"Unexpected error processing {file_path}: {e}\"\n                self.log(msg)\n                if not silent_errors:\n                    raise\n                return None\n\n        if not file_list:\n            msg = \"No files to process.\"\n            raise ValueError(msg)\n\n        concurrency = 1 if not self.use_multithreading else max(1, self.concurrency_multithreading)\n        file_count = len(file_list)\n\n        parallel_processing_threshold = 2\n        if concurrency < parallel_processing_threshold or file_count < parallel_processing_threshold:\n            if file_count > 1:\n                self.log(f\"Processing {file_count} files sequentially.\")\n            processed_data = [process_file(str(file.path), silent_errors=self.silent_errors) for file in file_list]\n        else:\n            self.log(f\"Starting parallel processing of {file_count} files with concurrency: {concurrency}.\")\n            file_paths = [str(file.path) for file in file_list]\n            processed_data = parallel_load_data(\n                file_paths,\n                silent_errors=self.silent_errors,\n                load_function=process_file,\n                max_concurrency=concurrency,\n            )\n\n        # Use rollup_basefile_data to merge processed data with BaseFile objects\n        return self.rollup_data(file_list, processed_data)\n"
              },
              "concurrency_multithreading": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Processing Concurrency",
                "dynamic": false,
                "info": "When multiple files are being processed, the number of files to process concurrently.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "concurrency_multithreading",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 4
              },
              "delete_server_file_after_processing": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Delete Server File After Processing",
                "dynamic": false,
                "info": "If true, the Server File Path will be deleted after processing.",
                "list": false,
                "list_add_label": "Add More",
                "name": "delete_server_file_after_processing",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "file_path": {
                "_input_type": "HandleInput",
                "advanced": true,
                "display_name": "Server File Path",
                "dynamic": false,
                "info": "Data object with a 'file_path' property pointing to server file or a Message object with a path to the file. Supercedes 'Path' but supports same file types.",
                "input_types": [
                  "Data",
                  "Message"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "file_path",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "ignore_unspecified_files": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Ignore Unspecified Files",
                "dynamic": false,
                "info": "If true, Data with no 'file_path' property will be ignored.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ignore_unspecified_files",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "ignore_unsupported_extensions": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Ignore Unsupported Extensions",
                "dynamic": false,
                "info": "If true, files with unsupported extensions will not be processed.",
                "list": false,
                "list_add_label": "Add More",
                "name": "ignore_unsupported_extensions",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "path": {
                "_input_type": "FileInput",
                "advanced": false,
                "display_name": "Files",
                "dynamic": false,
                "fileTypes": [
                  "txt",
                  "md",
                  "mdx",
                  "csv",
                  "json",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "pdf",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "zip",
                  "tar",
                  "tgz",
                  "bz2",
                  "gz"
                ],
                "file_path": [
                  "74e3a67b-29bf-4e09-974c-d3beb0364c23/7a8652c0-d86f-4ab1-af9d-fde07478cb16.pdf"
                ],
                "info": "Supported file extensions: txt, md, mdx, csv, json, yaml, yml, xml, html, htm, pdf, docx, py, sh, sql, js, ts, tsx; optionally bundled in file extensions: zip, tar, tgz, bz2, gz",
                "list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "path",
                "placeholder": "",
                "required": false,
                "show": true,
                "temp_file": false,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "separator": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "Specify the separator to use between multiple outputs in Message format.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "separator",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n\n"
              },
              "silent_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Silent Errors",
                "dynamic": false,
                "info": "If true, errors will not raise an exception.",
                "list": false,
                "list_add_label": "Add More",
                "name": "silent_errors",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "use_multithreading": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "[Deprecated] Use Multithreading",
                "dynamic": false,
                "info": "Set 'Processing Concurrency' greater than 1 to enable multithreading.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "use_multithreading",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              }
            },
            "tool_mode": false
          },
          "type": "File"
        },
        "dragging": false,
        "height": 232,
        "id": "File-sQtW8",
        "measured": {
          "height": 232,
          "width": 320
        },
        "position": {
          "x": 930.2523184385634,
          "y": -139.95093797948496
        },
        "positionAbsolute": {
          "x": 155.39382083637838,
          "y": -82.32805525710685
        },
        "selected": false,
        "type": "genericNode",
        "width": 320
      },
      {
        "data": {
          "description": "Create a prompt template with dynamic variables.",
          "display_name": "Prompt",
          "id": "Prompt-gdYgY",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": []
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Extract Prompt",
            "documentation": "",
            "edited": true,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "prompts",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.4.0",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt Message",
                "hidden": null,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": null,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Extract Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "Du bist ein spezialisierter KI-Assistent für die Zuordnung von Datenfeldern anhand von Dokumenttexten und Feldlisten.\nDeine Aufgabe ist es, jedem Feld aus der Vorlage exakt den passenden Inhalt aus dem Dokument zuzuordnen. Antworte immer auf Deutsch.\nÜberprüfe dabei jede Zuordnung auf Korrektheit und gib das Ergebnis in einer klar strukturierten, sowohl im chat als auch von einer Maschine lesbaren form zurück. gib nur zeilen zurück, die daten beinhalten\n\n1. Fasse den PDF Text  kurz und prägnant zusammen und ermittele den Dokumenttyp anhand des inhaltes.\n\n\n2. Analysiere anschließend die Templatetabelle aus dem vorherigen Schritt und füge dann  beides zusammen :\n\n- Identifiziere alle Felder, deren Name und Kontext zum PDF Text passen.\n- Ergänze in der Template-Tabelle eine neue Spalte „Zugeordneter Inhalt“.\n- Trage in dieser Spalte für jedes Feld den entsprechenden Textabschnitt aus dem Dokument ein.\n- Falls für ein Feld kein passender Inhalt im Dokument gefunden wird, lasse die Zelle in „Zugeordneter Inhalt“ leer.\n\nGib die fertige Tabelle als Markdown-Tabelle aus.\n\n\n"
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "type": "Prompt"
        },
        "dragging": false,
        "height": 347,
        "id": "Prompt-gdYgY",
        "measured": {
          "height": 347,
          "width": 320
        },
        "position": {
          "x": 1354.4624458339915,
          "y": 826.6711946890097
        },
        "positionAbsolute": {
          "x": 895.1947781377585,
          "y": -59.89409263992732
        },
        "selected": false,
        "type": "genericNode",
        "width": 320
      },
      {
        "data": {
          "id": "PdfToImagesComponent-jqRP1",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Wandelt jede Seite eines PDFs in ein PNG-Bild um.",
            "display_name": "PDF to Images",
            "documentation": "",
            "edited": true,
            "field_order": [
              "data",
              "pdf_path"
            ],
            "frozen": false,
            "icon": "file-image",
            "legacy": false,
            "lf_version": "1.4.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Image Paths",
                "hidden": false,
                "method": "convert_pdf_to_images",
                "name": "image_paths",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import List, Optional, Any\r\nfrom langflow.custom import Component\r\nfrom langflow.io import StrInput, DataInput, Output\r\nfrom langflow.schema import Data\r\nfrom pdf2image import convert_from_path, convert_from_bytes\r\nimport os\r\nimport sys\r\nimport logging\r\n\r\nclass PdfToImagesComponent(Component):\r\n    \"\"\"\r\n    Convert each page of a PDF file into separate PNG image files.\r\n    Accepts either:\r\n      • the Data object(s) from a File node (preferred), or\r\n      • a raw path string in pdf_path.\r\n    \"\"\"\r\n    display_name = \"PDF to Images\"\r\n    name = \"PdfToImagesComponent\"\r\n    description = \"Wandelt jede Seite eines PDFs in ein PNG-Bild um.\"\r\n    icon = \"file-image\"\r\n    \r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        # Initialize logger - fallback to standard logging if component logger isn't available\r\n        self._logger = None\r\n    \r\n    @property\r\n    def logger(self):\r\n        if self._logger is None:\r\n            # Try to get component's logger if available\r\n            component_logger = getattr(super(), \"logger\", None)\r\n            if component_logger is not None:\r\n                self._logger = component_logger\r\n            else:\r\n                # Fallback to a standard logger\r\n                self._logger = logging.getLogger(self.__class__.__name__)\r\n                if not self._logger.handlers:\r\n                    handler = logging.StreamHandler()\r\n                    formatter = logging.Formatter('%(name)s - %(levelname)s - %(message)s')\r\n                    handler.setFormatter(formatter)\r\n                    self._logger.addHandler(handler)\r\n                    self._logger.setLevel(logging.INFO)\r\n        return self._logger\r\n    \r\n    def log_info(self, message):\r\n        \"\"\"Safely log an info message, handling cases where logger might not be available\"\"\"\r\n        try:\r\n            self.logger.info(message)\r\n        except (AttributeError, Exception) as e:\r\n            print(f\"PDF to Images - INFO: {message}\")\r\n    \r\n    def log_warning(self, message):\r\n        \"\"\"Safely log a warning message, handling cases where logger might not be available\"\"\"\r\n        try:\r\n            self.logger.warning(message)\r\n        except (AttributeError, Exception) as e:\r\n            print(f\"PDF to Images - WARNING: {message}\")\r\n    \r\n    def log_error(self, message):\r\n        \"\"\"Safely log an error message, handling cases where logger might not be available\"\"\"\r\n        try:\r\n            self.logger.error(message)\r\n        except (AttributeError, Exception) as e:\r\n            print(f\"PDF to Images - ERROR: {message}\")\r\n\r\n    # Auto-detect poppler path from environment\r\n    @staticmethod\r\n    def get_poppler_path():\r\n        # First check if we're in a virtual environment\r\n        venv_path = os.environ.get(\"VIRTUAL_ENV\", \"\")\r\n        \r\n        # List of potential poppler paths to check\r\n        potential_paths = []\r\n        \r\n        # Check for different directory structures\r\n        if venv_path:\r\n            potential_paths.extend([\r\n                os.path.join(venv_path, \"poppler\", \"Library\", \"bin\"),\r\n                os.path.join(venv_path, \"poppler\", \"poppler-24.02.0\", \"bin\"),\r\n                os.path.join(venv_path, \"poppler\", \"bin\")\r\n            ])\r\n        \r\n        # Get the path of the current script/module\r\n        module_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\r\n        \r\n        # Add more potential paths based on known directory structures\r\n        potential_paths.extend([\r\n            os.path.join(module_dir, \"langflow_venv\", \"poppler\", \"Library\", \"bin\"),\r\n            os.path.join(module_dir, \"langflow_venv\", \"poppler\", \"poppler-24.02.0\", \"bin\"),\r\n            os.path.join(module_dir, \"Release-24.08.0-0\", \"poppler-24.08.0\", \"Library\", \"bin\"),\r\n            os.path.join(module_dir, \"Release-24.08.0-0\", \"poppler-24.08.0\", \"bin\"),\r\n            \"D:\\\\dev\\\\Langflow\\\\langflow\\\\Release-24.08.0-0\\\\poppler-24.08.0\\\\Library\\\\bin\",\r\n            \"D:\\\\dev\\\\Langflow\\\\langflow\\\\langflow_venv\\\\poppler\\\\poppler-24.02.0\\\\bin\",\r\n            \"D:\\\\dev\\\\Langflow\\\\langflow\\\\langflow_venv\\\\poppler\\\\Library\\\\bin\",\r\n            os.path.join(os.path.dirname(os.path.abspath(__file__)), \"..\", \"poppler\", \"Library\", \"bin\"),\r\n            \"C:\\\\Program Files\\\\poppler\\\\bin\",\r\n            \"C:\\\\Program Files (x86)\\\\poppler\\\\bin\",\r\n        ])\r\n        \r\n        # Try to find pdftoppm.exe in system PATH\r\n        if sys.platform == 'win32':\r\n            exe_name = 'pdftoppm.exe'\r\n        else:\r\n            exe_name = 'pdftoppm'\r\n            \r\n        for path_dir in os.environ.get('PATH', '').split(os.pathsep):\r\n            exe_path = os.path.join(path_dir, exe_name)\r\n            if os.path.isfile(exe_path):\r\n                return path_dir\r\n        \r\n        # Check if any of our potential paths exist\r\n        for path in potential_paths:\r\n            if path and os.path.exists(path):\r\n                # Verify it contains the necessary executables\r\n                if os.path.exists(os.path.join(path, exe_name)):\r\n                    return path\r\n        \r\n        return \"\"  # Empty string if not found\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"data\",\r\n            display_name=\"File Data\",\r\n            info=\"Data object(s) from a File node (contains file_path or raw bytes).\",\r\n            dynamic=True,\r\n            show=True,\r\n        ),\r\n        StrInput(\r\n            name=\"pdf_path\",\r\n            display_name=\"PDF Path\",\r\n            info=\"Optionaler Dateipfad (z. B. vom File node → Path).\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"image_paths\",\r\n            display_name=\"Image Paths\",\r\n            method=\"convert_pdf_to_images\",\r\n            info=\"Liste der generierten PNG-Pfade.\",\r\n        ),\r\n    ]\r\n\r\n    def convert_pdf_to_images(self) -> Data:\r\n        images = None  # will hold our list of PIL images\r\n        \r\n        # Get poppler path automatically\r\n        poppler_path = PdfToImagesComponent.get_poppler_path()\r\n        if poppler_path:\r\n            self.log_info(f\"Using Poppler from: {poppler_path}\")\r\n        else:\r\n            self.log_warning(\"No Poppler installation found. PDF conversion may fail.\")\r\n\r\n        # Log poppler directory contents for debugging\r\n        if poppler_path and os.path.exists(poppler_path):\r\n            try:\r\n                self.log_info(f\"Poppler directory contents: {os.listdir(poppler_path)}\")\r\n            except Exception as e:\r\n                self.log_error(f\"Could not list Poppler directory: {e}\")\r\n\r\n        # ─── 1) Normalize self.data to a single Data object ───\r\n        data_obj: Optional[Data] = None\r\n        if self.data is not None:\r\n            if isinstance(self.data, list) and len(self.data) > 0:\r\n                data_obj = self.data[0]\r\n            elif not isinstance(self.data, list):\r\n                data_obj = self.data\r\n\r\n        # ─── 2) Try extracting file_path from that Data object ───\r\n        if data_obj:\r\n            file_path = getattr(data_obj, \"file_path\", None)\r\n            if not file_path and isinstance(data_obj.data, dict):\r\n                file_path = data_obj.data.get(\"file_path\")\r\n            if file_path:\r\n                # we have a real filesystem path\r\n                try:\r\n                    self.log_info(f\"Converting from file path: {file_path}\")\r\n                    images = convert_from_path(file_path, dpi=600, poppler_path=poppler_path)\r\n                    self.log_info(f\"Successfully converted PDF from path with poppler at {poppler_path}\")\r\n                except Exception as e:\r\n                    self.log_error(f\"Error converting from path: {e}\")\r\n                    # Try without poppler_path as fallback\r\n                    try:\r\n                        self.log_info(\"Trying conversion without explicit poppler path\")\r\n                        images = convert_from_path(file_path, dpi=600)\r\n                        self.log_info(\"Conversion successful without explicit poppler path\")\r\n                    except Exception as e2:\r\n                        self.log_error(f\"Second attempt failed: {e2}\")\r\n\r\n            # ─── 3) Fallback: try raw bytes in the same Data object ───\r\n            if images is None and isinstance(data_obj.data, dict):\r\n                raw = data_obj.data.get(\"data\") or data_obj.data.get(\"bytes\")\r\n                if isinstance(raw, (bytes, bytearray)):\r\n                    try:\r\n                        self.log_info(\"Converting from raw bytes\")\r\n                        images = convert_from_bytes(raw, dpi=600, poppler_path=poppler_path)\r\n                        self.log_info(f\"Successfully converted PDF from bytes with poppler at {poppler_path}\")\r\n                    except Exception as e:\r\n                        self.log_error(f\"Error converting from bytes: {e}\")\r\n                        # Try without poppler_path as fallback\r\n                        try:\r\n                            self.log_info(\"Trying conversion from bytes without explicit poppler path\")\r\n                            images = convert_from_bytes(raw, dpi=600)\r\n                            self.log_info(\"Conversion from bytes successful without explicit poppler path\")\r\n                        except Exception as e2:\r\n                            self.log_error(f\"Second bytes attempt failed: {e2}\")\r\n\r\n        # ─── 4) Final fallback: pdf_path string if nothing above worked ───\r\n        if images is None and self.pdf_path:\r\n            try:\r\n                self.log_info(f\"Converting from pdf_path: {self.pdf_path}\")\r\n                images = convert_from_path(self.pdf_path, dpi=600, poppler_path=poppler_path)\r\n                self.log_info(f\"Successfully converted PDF from pdf_path with poppler at {poppler_path}\")\r\n            except Exception as e:\r\n                self.log_error(f\"Error with pdf_path: {e}\")\r\n                try:\r\n                    self.log_info(\"Trying final conversion without explicit poppler path\")\r\n                    images = convert_from_path(self.pdf_path, dpi=600)\r\n                    self.log_info(\"Final conversion successful without explicit poppler path\")\r\n                except Exception as e2:\r\n                    raise ValueError(f\"Konnte PDF nicht per pdf_path laden: {e2}\")\r\n\r\n        # ─── If still no images, abort ───\r\n        if images is None:\r\n            raise ValueError(\"Keine gültigen PDF-Daten gefunden (weder data noch pdf_path).\")\r\n\r\n        # ─── 5) Save pages to PNG and collect paths ───\r\n        paths: List[str] = []\r\n        for idx, img in enumerate(images):\r\n            # Use a more accessible temp directory on Windows\r\n            temp_dir = os.environ.get(\"TEMP\", \"C:\\\\Windows\\\\Temp\")\r\n            out_path = os.path.join(temp_dir, f\"pdf_page_{idx+1}.png\")\r\n            img.save(out_path, \"PNG\")\r\n            paths.append(out_path)\r\n\r\n        self.status = f\"Erzeugt {len(paths)} Seitenbilder\"\r\n        return Data(data={\"image_paths\": paths})\r\n"
              },
              "data": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "File Data",
                "dynamic": true,
                "info": "Data object(s) from a File node (contains file_path or raw bytes).",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "pdf_path": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "PDF Path",
                "dynamic": false,
                "info": "Optionaler Dateipfad (z. B. vom File node → Path).",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "pdf_path",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "PdfToImagesComponent"
        },
        "dragging": false,
        "id": "PdfToImagesComponent-jqRP1",
        "measured": {
          "height": 294,
          "width": 320
        },
        "position": {
          "x": 945.7895500507992,
          "y": 184.70988481316076
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "TesseractLocalOCR-pS1zU",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Runs pytesseract on each PNG (preprocessed) and concatenates the results.",
            "display_name": "Tesseract OCR (Local)",
            "documentation": "",
            "edited": true,
            "field_order": [
              "file_data"
            ],
            "frozen": false,
            "icon": "text",
            "legacy": false,
            "lf_version": "1.4.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Extracted Text",
                "hidden": false,
                "method": "extract_text",
                "name": "ocr_text",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "# custom_nodes/tesseract_local_ocr.py\r\n\r\nfrom typing import List, Any, Tuple\r\nfrom langflow.custom import Component\r\nfrom langflow.io import DataInput, Output\r\nfrom langflow.schema import Data\r\nfrom PIL import Image, ImageFilter\r\nimport pytesseract\r\nimport os\r\nimport sys\r\nimport subprocess\r\nimport traceback\r\n\r\nclass TesseractLocalOCR(Component):\r\n    \"\"\"\r\n    Extract text from image files (PNGs) using pytesseract,\r\n    with simple logging helpers baked in.\r\n    \"\"\"\r\n    display_name = \"Tesseract OCR (Local)\"\r\n    name = \"TesseractLocalOCR\"\r\n    description = \"Runs pytesseract on each PNG (preprocessed) and concatenates the results.\"\r\n    icon = \"text\"\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"file_data\",\r\n            display_name=\"File Data\",\r\n            info=\"Data output from PdfToImagesComponent (unwraps image_paths).\",\r\n            dynamic=True,\r\n            show=True,\r\n        ),\r\n    ]\r\n    outputs = [\r\n        Output(\r\n            name=\"ocr_text\",\r\n            display_name=\"Extracted Text\",\r\n            method=\"extract_text\",\r\n            info=\"All page texts joined together.\",\r\n        ),\r\n    ]\r\n\r\n    def log_info(self, msg: str):\r\n        print(f\"[TesseractLocalOCR INFO] {msg}\")\r\n\r\n    def log_error(self, msg: str):\r\n        print(f\"[TesseractLocalOCR ERROR] {msg}\")\r\n        \r\n    def find_tesseract_in_common_locations(self):\r\n        \"\"\"Try to find Tesseract in common installation locations\"\"\"\r\n        potential_locations = [\r\n            # Project-specific installations\r\n            os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), \r\n                        \"langflow_venv\", \"tesseract\", \"tesseract.exe\"),\r\n            # Standard installations\r\n            r\"C:\\Program Files\\Tesseract-OCR\\tesseract.exe\",\r\n            r\"C:\\Program Files (x86)\\Tesseract-OCR\\tesseract.exe\",\r\n            os.path.join(os.environ.get(\"APPDATA\", \"\"), \"Local\", \"Programs\", \"Tesseract-OCR\", \"tesseract.exe\"),\r\n            os.path.join(os.environ.get(\"LOCALAPPDATA\", \"\"), \"Programs\", \"Tesseract-OCR\", \"tesseract.exe\"),\r\n        ]\r\n        \r\n        # Check the path environment variable\r\n        for path_dir in os.environ.get('PATH', '').split(os.pathsep):\r\n            potential_locations.append(os.path.join(path_dir, \"tesseract.exe\"))\r\n        \r\n        for location in potential_locations:\r\n            if os.path.isfile(location):\r\n                self.log_info(f\"Found Tesseract at: {location}\")\r\n                return location\r\n                \r\n        return None\r\n        \r\n    def check_tesseract_installation(self):\r\n        \"\"\"Check if Tesseract is installed and in PATH, return diagnostic info\"\"\"\r\n        try:\r\n            # First, try to find Tesseract in common locations\r\n            tesseract_path = self.find_tesseract_in_common_locations()\r\n            if tesseract_path:\r\n                # Set the tesseract command to the found path\r\n                pytesseract.pytesseract.tesseract_cmd = tesseract_path\r\n                \r\n            # Check if pytesseract can find the tesseract executable\r\n            tesseract_cmd = pytesseract.pytesseract.tesseract_cmd\r\n            self.log_info(f\"Tesseract command: {tesseract_cmd}\")\r\n            \r\n            # Check if the file exists\r\n            if not os.path.exists(tesseract_cmd):\r\n                self.log_error(f\"Tesseract executable not found at: {tesseract_cmd}\")\r\n                return False, f\"Tesseract executable not found at: {tesseract_cmd}\"\r\n            \r\n            # Try running tesseract version command\r\n            try:\r\n                result = subprocess.run([tesseract_cmd, \"--version\"], \r\n                                       capture_output=True, text=True, timeout=5)\r\n                if result.returncode == 0:\r\n                    self.log_info(f\"Tesseract version: {result.stdout.splitlines()[0]}\")\r\n                    return True, \"Tesseract is properly installed.\"\r\n                else:\r\n                    self.log_error(f\"Tesseract command failed: {result.stderr}\")\r\n                    return False, f\"Tesseract failed: {result.stderr}\"\r\n            except subprocess.SubprocessError as e:\r\n                self.log_error(f\"Error executing Tesseract: {e}\")\r\n                return False, f\"Error executing Tesseract: {e}\"\r\n            \r\n        except FileNotFoundError:\r\n            self.log_error(\"Tesseract executable not found in PATH\")\r\n            return False, \"Tesseract executable not found in PATH\"\r\n        except Exception as e:\r\n            self.log_error(f\"Error checking Tesseract: {e}\")\r\n            self.log_error(traceback.format_exc())\r\n            return False, f\"Error checking Tesseract: {e}\"\r\n            \r\n    def extract_text(self) -> Data:\r\n        # Check Tesseract installation\r\n        tesseract_ok, tesseract_msg = self.check_tesseract_installation()\r\n        if not tesseract_ok:\r\n            # Try to set tesseract command based on common locations\r\n            potential_paths = [\r\n                os.path.join(os.environ.get(\"VIRTUAL_ENV\", \"\"), \"tesseract\", \"tesseract.exe\"),\r\n                r\"C:\\Program Files\\Tesseract-OCR\\tesseract.exe\",\r\n                r\"C:\\Program Files (x86)\\Tesseract-OCR\\tesseract.exe\",\r\n                os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), \r\n                            \"langflow_venv\", \"tesseract\", \"tesseract.exe\"),\r\n                os.path.join(os.environ.get(\"APPDATA\", \"\"), \"Local\", \"Programs\", \"Tesseract-OCR\", \"tesseract.exe\"),\r\n                os.path.join(os.environ.get(\"LOCALAPPDATA\", \"\"), \"Programs\", \"Tesseract-OCR\", \"tesseract.exe\"),\r\n            ]\r\n            \r\n            for path in potential_paths:\r\n                if os.path.exists(path):\r\n                    self.log_info(f\"Found Tesseract at: {path}\")\r\n                    pytesseract.pytesseract.tesseract_cmd = path\r\n                    tesseract_ok = True\r\n                    break\r\n                    \r\n        # Print environment variables that might affect Tesseract\r\n        self.log_info(f\"PATH: {os.environ.get('PATH', '')}\")\r\n        self.log_info(f\"TESSDATA_PREFIX: {os.environ.get('TESSDATA_PREFIX', '')}\")\r\n        \r\n        # 1) Unwrap DataInput into raw_paths list\r\n        raw_paths: List[str] = []\r\n        for item in (self.file_data or []):\r\n            try:\r\n                # DataInput sometimes gives Data instances, sometimes (key,value) tuples\r\n                if isinstance(item, tuple) and len(item) == 2:\r\n                    data_dict = item[1]\r\n                elif hasattr(item, \"data\"):\r\n                    data_dict = item.data\r\n                else:\r\n                    self.log_error(f\"Unrecognized item in file_data: {item!r}\")\r\n                    continue\r\n                pages = data_dict.get(\"image_paths\", [])\r\n                if isinstance(pages, list):\r\n                    raw_paths.extend(pages)\r\n            except Exception as e:\r\n                self.log_error(f\"Failed to unwrap file_data entry: {e}\")\r\n\r\n        self.log_info(f\"OCR will process {len(raw_paths)} images: {raw_paths}\")\r\n\r\n        # 2) Loop, preprocess, OCR\r\n        texts: List[str] = []\r\n        for path in raw_paths:\r\n            try:\r\n                self.log_info(f\"Opening image: {path}\")\r\n                img = Image.open(path)\r\n\r\n                self.log_info(\"  → to grayscale\")\r\n                img = img.convert(\"L\")\r\n\r\n                self.log_info(\"  → unsharp mask\")\r\n                img = img.filter(ImageFilter.UnsharpMask(radius=2, percent=150, threshold=3))\r\n\r\n                self.log_info(\"  → binary threshold\")\r\n                img = img.point(lambda p: 255 if p > 150 else 0)\r\n\r\n                self.log_info(\"  → resize 1.5×\")\r\n                w, h = img.size\r\n                img = img.resize((int(w * 1.5), int(h * 1.5)), Image.BICUBIC)\r\n\r\n                self.log_info(\"  → running OCR\")\r\n                # Add tesseract command explicit setting to diagnose issues\r\n                if not tesseract_ok:\r\n                    err_msg = f\"Tesseract is not installed or not in PATH. {tesseract_msg}\"\r\n                    self.log_error(err_msg)\r\n                    texts.append(f\"[Error reading {path}: {err_msg}]\")\r\n                    continue\r\n                \r\n                # Find TESSDATA_PREFIX if not set\r\n                if not os.environ.get('TESSDATA_PREFIX'):\r\n                    tesseract_dir = os.path.dirname(pytesseract.pytesseract.tesseract_cmd)\r\n                    potential_tessdata_paths = [\r\n                        os.path.join(tesseract_dir, \"tessdata\"),\r\n                        os.path.join(os.path.dirname(tesseract_dir), \"tessdata\"),\r\n                        os.path.join(os.path.dirname(os.path.dirname(tesseract_dir)), \"tessdata\"),\r\n                    ]\r\n                    for tess_path in potential_tessdata_paths:\r\n                        if os.path.exists(tess_path) and os.path.isdir(tess_path):\r\n                            os.environ['TESSDATA_PREFIX'] = tess_path\r\n                            self.log_info(f\"Setting TESSDATA_PREFIX to {tess_path}\")\r\n                            break\r\n                \r\n                # Explicitly state language and config\r\n                try:\r\n                    txt = pytesseract.image_to_string(img, lang=\"deu\", config=\"--psm 3\")\r\n                except pytesseract.TesseractNotFoundError:\r\n                    self.log_error(\"Tesseract not found when executing OCR\")\r\n                    texts.append(f\"[Error reading {path}: Tesseract not found when executing OCR]\")\r\n                    continue\r\n                except Exception as e:\r\n                    self.log_error(f\"OCR error: {e}\")\r\n                    if \"not found\" in str(e).lower() or \"language\" in str(e).lower():\r\n                        # Try without language specification\r\n                        self.log_info(\"Trying OCR without language specification\")\r\n                        try:\r\n                            txt = pytesseract.image_to_string(img, config=\"--psm 3\")\r\n                        except Exception as e2:\r\n                            self.log_error(f\"Second OCR error: {e2}\")\r\n                            texts.append(f\"[Error reading {path}: {e2}]\")\r\n                            continue\r\n                    else:\r\n                        texts.append(f\"[Error reading {path}: {e}]\")\r\n                        continue\r\n                        \r\n                cleaned = txt.strip()\r\n                self.log_info(f\"    OCR result (first 100 chars): {cleaned[:100]!r}\")\r\n                texts.append(cleaned)\r\n\r\n            except Exception as e:\r\n                self.log_error(f\"Error on {path}: {e}\")\r\n                self.log_error(traceback.format_exc())\r\n                texts.append(f\"[Error reading {path}: {e}]\")\r\n\r\n        result = \"\\n\\n\".join(texts)\r\n        self.log_info(f\"Final OCR text length: {len(result)}\")\r\n        return Data(data={\"ocr_text\": result})\r\n"
              },
              "file_data": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "File Data",
                "dynamic": true,
                "info": "Data output from PdfToImagesComponent (unwraps image_paths).",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "file_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "TesseractLocalOCR"
        },
        "dragging": false,
        "id": "TesseractLocalOCR-pS1zU",
        "measured": {
          "height": 212,
          "width": 320
        },
        "position": {
          "x": 949.4671346573552,
          "y": 557.3863514334403
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "File-si0o5",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Parse RTF documents and extract plain text content",
            "display_name": "RTF Parser",
            "documentation": "",
            "edited": true,
            "field_order": [
              "rtf_file",
              "preserve_formatting"
            ],
            "frozen": false,
            "icon": "file-text",
            "legacy": false,
            "lf_version": "1.4.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "hidden": false,
                "method": "parse_rtf",
                "name": "parsed_text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Optional\r\nfrom langflow.custom import Component\r\nfrom langflow.io import FileInput, BoolInput, Output\r\nfrom langflow.schema import Message\r\nfrom pyth.plugins.rtf15.reader import Rtf15Reader\r\nfrom pyth.plugins.plaintext.writer import PlaintextWriter\r\nimport os\r\n\r\nclass RTFParserComponent(Component):\r\n    display_name = \"RTF Parser\"\r\n    description = \"Parse RTF documents and extract plain text content\"\r\n    icon = \"file-text\"\r\n    name = \"RTFParser\"\r\n\r\n    inputs = [\r\n        FileInput(\r\n            name=\"rtf_file\",\r\n            display_name=\"RTF File\",\r\n            info=\"Upload an RTF file to parse\",\r\n            file_types=[\"rtf\"],\r\n            required=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"preserve_formatting\",\r\n            display_name=\"Preserve Formatting\",\r\n            info=\"Whether to preserve basic formatting (like line breaks)\",\r\n            value=False,\r\n            advanced=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(display_name=\"Parsed Text\", name=\"parsed_text\", method=\"parse_rtf\"),\r\n    ]\r\n\r\n    def parse_rtf(self) -> Message:\r\n        try:\r\n            # Get the uploaded file path\r\n            file_path = self.rtf_file\r\n\r\n            if not file_path:\r\n                raise ValueError(\"No RTF file provided\")\r\n\r\n            if not os.path.exists(file_path):\r\n                raise ValueError(f\"File not found: {file_path}\")\r\n\r\n            # Read the RTF file in binary mode for pyth\r\n            with open(file_path, 'rb') as file:\r\n                doc = Rtf15Reader.read(file)\r\n\r\n            # Convert to plain text using pyth\r\n            if self.preserve_formatting:\r\n                # Extract text while preserving some structure\r\n                text_parts = []\r\n                for element in doc.content:\r\n                    if hasattr(element, 'content'):\r\n                        text_parts.append(str(element.content))\r\n                    else:\r\n                        text_parts.append(str(element))\r\n                text = '\\n'.join(text_parts)\r\n            else:\r\n                # Convert to plain text without formatting\r\n                text = PlaintextWriter.write(doc).getvalue()\r\n\r\n            self.status = f\"RTF parsed successfully. Extracted {len(text)} characters.\"\r\n\r\n            # Return as Message object\r\n            return Message(\r\n                text=text,\r\n                sender=\"RTF Parser\",\r\n                sender_name=\"RTF Parser Component\"\r\n            )\r\n\r\n        except Exception as e:\r\n            error_msg = f\"Error parsing RTF: {str(e)}\"\r\n            self.status = error_msg\r\n            return Message(\r\n                text=error_msg,\r\n                sender=\"RTF Parser\",\r\n                sender_name=\"RTF Parser Component\"\r\n            )"
              },
              "preserve_formatting": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Preserve Formatting",
                "dynamic": false,
                "info": "Whether to preserve basic formatting (like line breaks)",
                "list": false,
                "list_add_label": "Add More",
                "name": "preserve_formatting",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "rtf_file": {
                "_input_type": "FileInput",
                "advanced": false,
                "display_name": "RTF File",
                "dynamic": false,
                "fileTypes": [
                  "rtf"
                ],
                "file_path": "74e3a67b-29bf-4e09-974c-d3beb0364c23/3654956a-b28c-4da4-b874-84352e35c507.RTF",
                "info": "Upload an RTF file to parse",
                "list": false,
                "list_add_label": "Add More",
                "name": "rtf_file",
                "placeholder": "",
                "required": true,
                "show": true,
                "temp_file": false,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "RTFParser"
        },
        "dragging": false,
        "id": "File-si0o5",
        "measured": {
          "height": 256,
          "width": 320
        },
        "position": {
          "x": 469.1803769708433,
          "y": -110.27903794465067
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "description": "Create a prompt template with dynamic variables.",
          "display_name": "Prompt",
          "id": "Prompt-Jx0tt",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "Templatetabelle"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Template Prompt",
            "documentation": "",
            "edited": true,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "prompts",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.4.0",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt Message",
                "hidden": false,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": null,
            "template": {
              "Templatetabelle": {
                "advanced": false,
                "display_name": "Templatetabelle",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "Templatetabelle",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Template Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "In dem RTF Text gibt es Platzhalterfelder , erkennbar an ??.\nFinde aus ihrem Kontext heraus, wofür sie stehen, und gib ihnen einen Feldnamen. Nummeriere die Feldnamen\n\nErmittele die Dokumentenart prägnant aus Titel und Inhalt\nErstelle dann eine Tabelle für alle gefundenen Platzhalter aus Feldnamen, Nummer, und Kontext des Feldes, Füge eine spalte für Dokumentenart und eine für Dokumententitel an.\nWenn Du den Kontext nicht klar interpretierenkonntest, laß den Feldnamen leer.\n\nErzeuge daraus die {Templatetabelle}.\n\n\n\n\n\n\n"
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "type": "Prompt"
        },
        "dragging": false,
        "id": "Prompt-Jx0tt",
        "measured": {
          "height": 413,
          "width": 320
        },
        "position": {
          "x": 1354.807962409788,
          "y": 281.896359974159
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatInput-KwmJ2",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get chat inputs from the Playground.",
            "display_name": "Chat Input",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "files",
              "background_color",
              "chat_icon",
              "text_color"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.4.0",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n            input_types=[],\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n            temp_file=True,\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        background_color = self.background_color\n        text_color = self.text_color\n        icon = self.chat_icon\n\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n            properties={\n                \"background_color\": background_color,\n                \"text_color\": text_color,\n                \"icon\": icon,\n            },\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n"
              },
              "files": {
                "_input_type": "FileInput",
                "advanced": true,
                "display_name": "Files",
                "dynamic": false,
                "fileTypes": [
                  "txt",
                  "md",
                  "mdx",
                  "csv",
                  "json",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "pdf",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "file_path": "",
                "info": "Files to be sent with the message.",
                "list": true,
                "list_add_label": "Add More",
                "name": "files",
                "placeholder": "",
                "required": false,
                "show": true,
                "temp_file": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Message to be passed as input.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "starten"
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatInput"
        },
        "dragging": false,
        "id": "ChatInput-KwmJ2",
        "measured": {
          "height": 66,
          "width": 192
        },
        "position": {
          "x": 149.2928009745745,
          "y": 113.958123220488
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "CustomComponent-wJ5Yy",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "1) Extract structured data, 2) Compose final answer with user query—all in one node.",
            "display_name": "Ollama Two-Phase",
            "documentation": "",
            "edited": true,
            "field_order": [
              "pdf_text",
              "rtf_text",
              "extract_prompt",
              "compose_prompt",
              "chat_input",
              "base_url",
              "model",
              "max_tokens",
              "temperature"
            ],
            "frozen": false,
            "icon": "layers",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Final Response",
                "hidden": null,
                "method": "build_output",
                "name": "response",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "base_url": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Ollama Base URL",
                "dynamic": false,
                "info": "e.g. http://host.docker.internal:11434",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "base_url",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "http://host.docker.internal:11434"
              },
              "chat_input": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "User Query",
                "dynamic": false,
                "info": "The user’s actual question or additional instructions",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "chat_input",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\r\nfrom langflow.inputs import StrInput, MultilineInput\r\nfrom langflow.template import Output\r\nfrom langflow.schema import Data\r\nimport requests\r\n\r\nclass OllamaTwoPhase(Component):\r\n    display_name = \"Ollama Two-Phase\"\r\n    name = \"OllamaTwoPhase\"\r\n    description = \"1) Extract structured data, 2) Compose final answer with user query—all in one node.\"\r\n    icon = \"layers\"\r\n\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"pdf_text\",\r\n            display_name=\"PDF Text\",\r\n            info=\"OCR’d text from your PDF\",\r\n            value=\"\"\r\n        ),\r\n        MultilineInput(\r\n            name=\"rtf_text\",\r\n            display_name=\"RTF Text\",\r\n            info=\"Text extracted from your RTF/Word template\",\r\n            value=\"\"\r\n        ),\r\n        MultilineInput(\r\n            name=\"extract_prompt\",\r\n            display_name=\"Extract Prompt\",\r\n            info=\"Template prompt to pull structured data (e.g. JSON/table) from the PDF text\",\r\n            value=\"Extract the key table from the following PDF text as JSON…\"\r\n        ),\r\n        MultilineInput(\r\n            name=\"compose_prompt\",\r\n            display_name=\"Compose (System) Prompt\",\r\n            info=\"System‐style instructions for how to produce the final answer\",\r\n            value=\"Using the extracted data plus PDF/RTF content, create a comprehensive summary…\"\r\n        ),\r\n        MultilineInput(\r\n            name=\"chat_input\",\r\n            display_name=\"User Query\",\r\n            info=\"The user’s actual question or additional instructions\",\r\n            value=\"\"\r\n        ),\r\n        StrInput(\r\n            name=\"base_url\",\r\n            display_name=\"Ollama Base URL\",\r\n            info=\"e.g. http://host.docker.internal:11434\",\r\n            value=\"http://host.docker.internal:11434\"\r\n        ),\r\n        StrInput(\r\n            name=\"model\",\r\n            display_name=\"Model Name\",\r\n            info=\"Leave blank for Ollama’s default\",\r\n            value=\"\"\r\n        ),\r\n        StrInput(\r\n            name=\"max_tokens\",\r\n            display_name=\"Max Tokens\",\r\n            info=\"Max tokens per call\",\r\n            value=\"512\"\r\n        ),\r\n        StrInput(\r\n            name=\"temperature\",\r\n            display_name=\"Temperature\",\r\n            info=\"Sampling temperature\",\r\n            value=\"0.7\"\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(display_name=\"Final Response\", name=\"response\", method=\"build_output\")\r\n    ]\r\n\r\n    def build_output(self) -> Data:\r\n        base = self.base_url.rstrip(\"/\")\r\n\r\n        def call_ollama(prompt: str) -> str:\r\n            payload = {\r\n                \"model\": self.model or None,\r\n                \"prompt\": prompt,\r\n                \"max_tokens\": int(self.max_tokens),\r\n                \"temperature\": float(self.temperature),\r\n            }\r\n            resp = requests.post(f\"{base}/api/generate\", json=payload, timeout=30)\r\n            resp.raise_for_status()\r\n            return resp.json().get(\"response\", \"\")\r\n\r\n        # 1) Extract structured data from the PDF\r\n        extracted = call_ollama(\r\n            f\"{self.extract_prompt}\\n\\nPDF TEXT:\\n{self.pdf_text}\"\r\n        )\r\n\r\n        # 2) Compose final answer: include system instructions, user query, extracted data, and both docs\r\n        final_prompt = (\r\n            f\"{self.compose_prompt}\\n\\n\"\r\n            f\"User Query:\\n{self.chat_input}\\n\\n\"\r\n            f\"Extracted Data:\\n{extracted}\\n\\n\"\r\n            f\"Full PDF Text:\\n{self.pdf_text}\\n\\n\"\r\n            f\"Full RTF Text:\\n{self.rtf_text}\"\r\n        )\r\n        final = call_ollama(final_prompt)\r\n\r\n        self.status = \"Done\"\r\n        return Data(value=final)\r\n"
              },
              "compose_prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Compose (System) Prompt",
                "dynamic": false,
                "info": "System‐style instructions for how to produce the final answer",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "compose_prompt",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Using the extracted JSON plus the PDF/RTF text, write me a summary…"
              },
              "extract_prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Extract Prompt",
                "dynamic": false,
                "info": "Template prompt to pull structured data (e.g. JSON/table) from the PDF text",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "extract_prompt",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Extract the key table from the following PDF text as JSON…"
              },
              "max_tokens": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Max Tokens",
                "dynamic": false,
                "info": "Max tokens per call",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "max_tokens",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "512"
              },
              "model": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Model Name",
                "dynamic": false,
                "info": "Leave blank for Ollama’s default",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "model",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "pdf_text": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "PDF Text",
                "dynamic": false,
                "info": "OCR’d text from your PDF",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pdf_text",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "rtf_text": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "RTF Text",
                "dynamic": false,
                "info": "Text extracted from your RTF/Word template",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "rtf_text",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "temperature": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Sampling temperature",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "temperature",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "0.7"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "OllamaTwoPhase"
        },
        "dragging": false,
        "id": "CustomComponent-wJ5Yy",
        "measured": {
          "height": 923,
          "width": 320
        },
        "position": {
          "x": 1756.5785287868807,
          "y": 140.1212215326229
        },
        "selected": true,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParseData-WoS96",
          "node": {
            "base_classes": [
              "Data",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Convert Data objects into Messages using any {field_name} from input data.",
            "display_name": "Data to Message",
            "documentation": "",
            "edited": false,
            "field_order": [
              "data",
              "template",
              "sep"
            ],
            "frozen": false,
            "icon": "message-square",
            "legacy": true,
            "metadata": {
              "legacy_name": "Parse Data"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "hidden": false,
                "method": "parse_data",
                "name": "text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data List",
                "method": "parse_data_as_list",
                "name": "data_list",
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.helpers.data import data_to_text, data_to_text_list\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass ParseDataComponent(Component):\n    display_name = \"Data to Message\"\n    description = \"Convert Data objects into Messages using any {field_name} from input data.\"\n    icon = \"message-square\"\n    name = \"ParseData\"\n    legacy = True\n    metadata = {\n        \"legacy_name\": \"Parse Data\",\n    }\n\n    inputs = [\n        DataInput(\n            name=\"data\",\n            display_name=\"Data\",\n            info=\"The data to convert to text.\",\n            is_list=True,\n            required=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {data} or any other key in the Data.\",\n            value=\"{text}\",\n            required=True,\n        ),\n        StrInput(name=\"sep\", display_name=\"Separator\", advanced=True, value=\"\\n\"),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"text\",\n            info=\"Data as a single Message, with each input Data separated by Separator\",\n            method=\"parse_data\",\n        ),\n        Output(\n            display_name=\"Data List\",\n            name=\"data_list\",\n            info=\"Data as a list of new Data, each having `text` formatted by Template\",\n            method=\"parse_data_as_list\",\n        ),\n    ]\n\n    def _clean_args(self) -> tuple[list[Data], str, str]:\n        data = self.data if isinstance(self.data, list) else [self.data]\n        template = self.template\n        sep = self.sep\n        return data, template, sep\n\n    def parse_data(self) -> Message:\n        data, template, sep = self._clean_args()\n        result_string = data_to_text(template, data, sep)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def parse_data_as_list(self) -> list[Data]:\n        data, template, _ = self._clean_args()\n        text_list, data_list = data_to_text_list(template, data)\n        for item, text in zip(data_list, text_list, strict=True):\n            item.set_text(text)\n        self.status = data_list\n        return data_list\n"
              },
              "data": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Data",
                "dynamic": false,
                "info": "The data to convert to text.",
                "input_types": [
                  "Data"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sep": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              },
              "template": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParseData"
        },
        "dragging": false,
        "id": "ParseData-WoS96",
        "measured": {
          "height": 342,
          "width": 320
        },
        "position": {
          "x": 2187.4439367138175,
          "y": -121.19050953208051
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": -172.98908692695102,
      "y": 179.48801070380267,
      "zoom": 0.4999999999999999
    }
  },
  "description": "Integrates PDF reading with a language model to answer document-specific questions. Ideal for small-scale texts, it facilitates direct queries with immediate insights.",
  "endpoint_name": null,
  "folder_id": "a3f7bf87-856c-4f70-8e28-8290a2f866b7",
  "fs_path": null,
  "gradient": "3",
  "icon": "FileQuestion",
  "icon_bg_color": null,
  "id": "a4b6b60c-f590-46b4-a2b0-3db6727bc63b",
  "is_component": false,
  "locked": false,
  "mcp_enabled": true,
  "name": "PDF mit Wordtemplate abgleichen, two phased ",
  "tags": [],
  "updated_at": "2025-05-27T11:02:08+00:00",
  "user_id": "74e3a67b-29bf-4e09-974c-d3beb0364c23",
  "webhook": false
}